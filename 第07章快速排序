快速排序的描述
  分解：数组A[p..r]被划分为两个（可能为空）子数组A[p..q-1]和A[q+1..r],是的A[p..q-1]中的每一个元素都小于等于A[q],
       而A[q]也小于等于A[q+1..r]中的每个元素。其中，计算下标q也是划分过程的一部分
  解决：通过递归调用快速排序，对于子数组A[p..q-1]和A[q+1..r]进行排序
  合并：因为子数组都是原址排序，所以不需要合并操作，数组A已有序
  
QUICKSORT(A, p, r)  
  if p < r
    q = PARTITION(A, p, r)
    QUICKSORT(A, p, q-1) 
    QUICKSORT(A, p, q+1)
为了排序一个数组A的全部元素，初始调用是QUICKSORT（A, 1, A.length）

数组的划分
PARTITION（A, p, r)
  x = A[r]
  i = p - 1
  for j = p to r-1
    if A[j] <= x
      i = i + 1
      exchange A[i] with A[j]
  exchange A[i + 1] with A[r]
  return i + 1
时间复杂度：O(n)


快速排序的性能
  快速排序的性能依赖于划分是否平衡，而平衡与否有依赖于用于划分的元素。
  如果划分是平衡的，那么快速排序的算法性能就和归并排序一样，否则就接近于插入排序。
  最坏情况划分：两个子问题分别包含了n-1个元素和0个元素
  最好情况划分：两个子问题规模都不大于n/2
  平衡的划分：快速排序的平均运行时间更接近于最好情况。
事实上，任何一种常数比例的划分都会产生深度为O(lgn)的递归树，每一层的时间代价都是O(n),因此，只要划分是常数比例，
算法的运行时间总是O(nlgn)

